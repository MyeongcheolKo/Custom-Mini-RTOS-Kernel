/*
 * SPI_driver.c
 *
 *  Created on: Dec 28, 2025
 *      Author: krisko
 */

#include "SPI_driver.h"

/*
 * @fcn:		SPI_clock_control
 *
 * #brief:		This function enable/disable the clock for the given SPI peripheral
 *
 * @param:		base address of SPI peripheral
 * @param:		ENABLE or DISABLE
 *
 * @return:		none
 */
void SPI_clock_control(SPI_reg_t *p_SPIx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		if(p_SPIx == SPI1)
		{
			SPI1_PCLK_EN();
		}
		else if(p_SPIx == SPI2)
		{
			SPI2_PCLK_EN();
		}
		else if(p_SPIx == SPI3)
		{
			SPI3_PCLK_EN();
		}
		else if(p_SPIx == SPI4)
		{
			SPI4_PCLK_EN();
		}
	}else
	{
		if(p_SPIx == SPI1)
		{
			SPI1_PCLK_DI();
		}
		else if(p_SPIx == SPI2)
		{
			SPI2_PCLK_DI();
		}
		else if(p_SPIx == SPI3)
		{
			SPI3_PCLK_DI();
		}
		else if(p_SPIx == SPI4)
		{
			SPI4_PCLK_DI();
		}
	}
}


/*
 * @fcn:		SPI_init
 *
 * #brief:		This function configures the SPI peripheral with the given configuration
 *
 * @param:		address of SPI Handle
 *
 * @return:		none
 *
 * @note: 			this function enables the peripheral clock
 */
void SPI_init(SPI_Handle_t *p_SPI_Handle){

	//enable the peripheral clock
	SPI_clock_control(p_SPI_Handle->p_SPIx, ENABLE);

	uint32_t temp = 0;
	temp = p_SPI_Handle->p_SPIx->CR1;


	//configure device mode
	temp &= ~(1 << SPI_CR1_MSTR);
	temp |= (p_SPI_Handle->SPI_config.SPI_device_mode << SPI_CR1_MSTR);

	uint8_t bus = p_SPI_Handle->SPI_config.SPI_bus_config;
	//configure device bus
	if(bus == SPI_BUS_CONFIG_FD){
		//clear BIDIMODE bit -> full-duplex
		temp &= ~(1 << SPI_CR1_BIDIMODE);
		//clear RXONLY bit to be safe
		temp &= ~(1 << SPI_CR1_RXONLY);
	}else if (bus == SPI_BUS_CONFIG_HD)
	{
		//set BIDIMODE bit -> hald-duplex
		temp |= (1 << SPI_CR1_BIDIMODE);
		//clear RXONLY bit to be safe
		temp &= ~(1 << SPI_CR1_RXONLY);
	}else if(bus == SPI_BUS_CONFIG_S_RXONLY)
	{
		//clear BIDIMODE bit
		temp &= ~(1 << SPI_CR1_BIDIMODE);
		//set RXONLY bit
		temp |= (1 << SPI_CR1_RXONLY);
	}

	//configure clock speed
	temp &= ~(0b111 << SPI_CR1_BR);
	temp |= (p_SPI_Handle->SPI_config.SPI_sclk_speed << SPI_CR1_BR);

	//configure DFF
	temp &= ~(1 << SPI_CR1_DFF);
	temp |= (p_SPI_Handle->SPI_config.SPI_DFF << SPI_CR1_DFF);

	//configure CPOL
	temp &= ~(1 << SPI_CR1_CPOL);
	temp |= (p_SPI_Handle->SPI_config.SPI_CPOL << SPI_CR1_CPOL);

	//configure CPHA
	temp &= ~(1 << SPI_CR1_CPHA);
	temp |= (p_SPI_Handle->SPI_config.SPI_CPHA << SPI_CR1_CPHA);

	//configure SSM
	temp &= ~(1 << SPI_CR1_SSM);
	temp |= (p_SPI_Handle->SPI_config.SPI_SSM << SPI_CR1_SSM);

	p_SPI_Handle->p_SPIx->CR1 = temp;
}

/*
 * @fcn:
 *
 * #brief:
 *
 * @param:
 *
 * @return:
 */
void SPI_deinit(SPI_config_t *p_SPIx){

}

/*
 * @fcn:		SPI_periph_control
 *
 * #brief:		This function enables the given SPI peripheral
 *
 * @param:		address of the SPI peripheral
 *
 * @return:		none
 *
 * @note:		should be called after SPI_init (after configuration is done)
 */
void SPI_periph_control(SPI_reg_t *p_SPIx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_SPIx->CR1 |= (1 << SPI_CR1_SPE);
	}else
	{
		p_SPIx->CR1 &= ~(1 << SPI_CR1_SPE);
	}
}

/*
 * @fcn:		SPI_send
 *
 * #brief:		This function sends data to the given SPI peripheral
 *
 * @param:		base address of SPI device
 * @param:		address of the Tx buffer
 * @param:		the length of byte to send
 *
 *
 * @return: 	none
 *
 * @note: 		this is a blocking call
 */
void SPI_send(SPI_reg_t *p_SPIx, uint8_t *p_Tx_buffer, uint32_t len){
	while(len > 0)
	{
		//wait until TXE is set (transmit buffer is empty)
		while(get_flag_status(p_SPIx, SPI_SR_TXE) == 0);

		//check DFF bit
		if(p_SPIx->CR1 & (1 << SPI_CR1_DFF)) //DFF bit is set, 16-bit
		{
			//write to data register(DR)
			p_SPIx->DR = *( (uint16_t*)p_Tx_buffer );  //cast to uint16_t then dereference to get 16 bits
			len -= 2;
			p_Tx_buffer += 2;
		}else		//DFF is not set, 8-bit
		{
			p_SPIx->DR = *p_Tx_buffer;
			len--;
			p_Tx_buffer++;
		}

	}
}

/*
 * @fcn:
 *
 * #brief:
 *
 * @param:
 *
 * @return:
 */
void SPI_recieve(SPI_reg_t *p_SPIx, uint8_t *p_Rx_buffer, uint32_t len){

}

/*
 * @fcn:
 *
 * #brief:
 *
 * @param:
 *
 * @return:
 */
void SPI_IRQ_config(uint8_t IRQ_num, uint8_t enable){

}

/*
 * @fcn:
 *
 * #brief:
 *
 * @param:
 *
 * @return:
 */
void SPI_set_priority(uint8_t IRQ_num, uint8_t IRQ_priority){

}

/*
 * @fcn:
 *
 * #brief:
 *
 * @param:
 *
 * @return:
 */
void SPI_IRQ_handler(SPI_Handle_t *p_SPI_Handle){

}

/*
 * @fcn:		get_flag_status
 *
 * #brief:		This function returns the status of the given flag bit of the SPI status register(SR)
 *
 * @param:		base address of the SPI device
 * @param:		the flag bit of the SR register to get status from
 *
 * @return:		the status of the given flag bit
 */
uint8_t SPI_get_flag_status(SPI_reg_t *p_SPIx, uint8_t flag_bit)
{
	return ( p_SPIx->SR & (1 << flag_bit) );
}

/*
 * @fcn:		SPI_SSI_config
 *
 * #brief:		This function enable/disable the SSI bit as given
 *
 * @param:		base address of the SPI device
 * @param:		ENABLE or DISABLE
 *
 * @return:		none
 */
void SPI_SSI_config(SPI_reg_t *p_SPIx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_SPIx->CR1 |= (1 << SPI_CR1_SSI);
	}
	else
	{
		p_SPIx->CR1 &= ~(1 << SPI_CR1_SSI);
	}
}

/*
 * @fcn:		SPI_SSOE_config
 *
 * #brief:		This function enable/disable the SSEO bit as given
 *
 * @param:		base address of the SPI device
 * @param:		ENABLE or DISABLE
 *
 * @return:		none
 */
void SPI_SSOE_config(SPI_reg_t *p_SPIx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_SPIx->CR1 |= (1 << SPI_CR2_SSOE);
	}
	else
	{
		p_SPIx->CR1 &= ~(1 << SPI_CR2_SSOE);
	}
}
