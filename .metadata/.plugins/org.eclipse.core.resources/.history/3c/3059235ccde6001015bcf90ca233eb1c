/*
 * I2C_driver.c
 *
 *  Created on: Dec 30, 2025
 *      Author: krisko
 */

#include "I2C_driver.h"
//private helper functions
static void I2C_generate_start(I2C_Handle_t *p_I2C_Handle);
static void I2C_execute_addr_phase(I2C_Handle_t *p_I2C_Handle, uint8_t slave_addr, uint8_t read_or_write);
static void I2C_clear_ADDR_flag(I2C_Handle_t *p_I2C_Handle);
static void I2C_generate_stop(I2C_Handle_t *p_I2C_Handle);

/*
 * @fcn:			I2C_clock_control
 *
 * @brief:			This function enable/disable the clock for the given I2C peripheral
 *
 * @param[in]:		address of I2C peripheral
 * @param[in]:		ENABLE or DISABLE
 *
 * @return:			none
 */
void I2C_clock_control(I2C_reg_t *p_I2Cx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		if(p_I2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(p_I2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(p_I2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}else
	{
		if(p_I2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(p_I2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(p_I2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

/*
 * @fcn:			I2C_init
 *
 * @brief:			This function configures the given I2C peripheral
 *
 * @param[in]:		address of I2C Handle for the peripheral
 *
 * @return:			none
 *
 * @note:			for system clock source, only HSI and HSE are considered, PLL and PLLR are not considered
 */
void I2C_init(I2C_Handle_t *p_I2C_Handle)
{
	uint32_t temp;
	uint32_t PCLK1_freq_hz = I2C_RCC_get_pclk1();

	//enable peripheral clock
	I2C_clock_control(p_I2C_Handle->p_I2Cx, ENABLE);


	//configure clock frequency
	uint32_t PCLK1_freq_Mhz = PCLK1_freq_hz / 1000000;	//FREQ only support Mhz
	temp = p_I2C_Handle->p_I2Cx->CR2;
	temp &= ~(0b11111 << I2C_CR2_FREQ);
	temp |= (PCLK1_freq_Mhz << I2C_CR2_FREQ);
	p_I2C_Handle->p_I2Cx->CR2 = temp;

	//configure device address mode
	temp = p_I2C_Handle->p_I2Cx->OAR1;
	temp &= ~(1 << I2C_OAR_ADDMODE);
	uint32_t addr_mode = p_I2C_Handle->I2Cx_config.I2C_addr_mode;
	temp |= (p_I2C_Handle->I2Cx_config.I2C_addr_mode << I2C_OAR_ADDMODE);

	//configure device address
	if(addr_mode) //10-bit mode
	{
		temp &= ~(0x3FF);
		temp |= (p_I2C_Handle->I2Cx_config.I2C_device_addr & 0x3FF);
	}
	else	//7bit mode
	{
		temp &= ~(0x7F << 1);
		temp |= ( (p_I2C_Handle->I2Cx_config.I2C_device_addr & 0x7F) << 1);
	}
	temp |= (1 << 14);	//keep 14th bit of OAR 1, as required by data sheet
	p_I2C_Handle->p_I2Cx->OAR1 = temp;

	//configure clock control register
	uint32_t CCR;
	temp = p_I2C_Handle->p_I2Cx->CCR;
	uint32_t clock_speed = p_I2C_Handle->I2Cx_config.I2C_CLK_speed;
	if( clock_speed <= I2C_CLK_SPEED_SM)
	{
		//standard mode
		temp &= ~(1 << I2C_CCR_FS);		//set mode to SM
		//calculate CCR
		CCR = PCLK1_freq_hz / (2 * clock_speed);
	}
	else
	{
		//fast mode
		temp |= (1 << I2C_CCR_FS);		//set mode to FM
		//set FR duty cycle
		uint8_t duty = p_I2C_Handle->I2Cx_config.I2C_FM_duty_cycle;
		if(duty)	//t(low)/t(high) = 16/9
		{
			//set DUTY to 1
			temp |= (duty << I2C_CCR_DUTY);
			//calculate CCR
			CCR = PCLK1_freq_hz / (25 * clock_speed);
		}
		else		//t(low)/t(high) = 2
		{
			//set DUTY to 0
			temp &= ~(1 << I2C_CCR_DUTY);
			//calculate CCR
			 CCR = PCLK1_freq_hz / (3 * clock_speed);

		}
	}
	temp &= ~(0xFFF << I2C_CCR_CCR);
	temp |= ((CCR & 0xFFF) << I2C_CCR_CCR);
	p_I2C_Handle->p_I2Cx->CCR = temp;

	//configure T(rise)
	temp = p_I2C_Handle->p_I2Cx->TRISE;
	temp &= ~(0x3F);
	if(clock_speed <= I2C_CLK_SPEED_SM)
	{
		//standard mode, T(rise) max = 1000ns
		temp |= (PCLK1_freq_hz / 1000000) + 1;		//add 1, as specified in data sheet
	}
	else
	{
		//fast mode, T(rise) max = 300ns
		temp |= ((PCLK1_freq_hz * 300) / 1000000000) + 1;
	}
	p_I2C_Handle->p_I2Cx->TRISE = (temp & 0x3F);
}

/*
 * @fcn:			RCC_get_pclk1
 *
 * @brief:			This function calculates the clock speed of APB1
 *
 * @return:			APB clock speed
 *
 * @note:			 only HSI and HSE are considered for system clock source, PLL is not considered
 */
uint32_t I2C_RCC_get_pclk1(void)
{
	static const uint32_t possible_pscals[] = {2,4,8,16,64,128,256,512};
	uint32_t system_clk, AHB_pscal, APB1_pscal;

	//find system clock source speed
	uint32_t clk_src = (RCC->CFGR >> 2) & 0b11;
	if(clk_src == 0){	//HSI
		system_clk = 16000000;
	}
	else if (clk_src == 1)	//HSE
	{
		system_clk = 8000000;
	}
	else
	{
		// PLL not supported, assume HSI as fallback
		system_clk = 16000000;
	}
	//find AHB prescalar
	uint32_t HPRE = (RCC->CFGR >> 4) & 0b1111;
	if(HPRE < 8) 	//vals below 0b1000 are all not divided by
		AHB_pscal = 1;
	else			//vals at 0b1000 and above are divided by
		AHB_pscal = possible_pscals[HPRE - 8];

	//find APB1 prescalar, I2C peripherals all under APB1
	uint32_t PPRE1 = (RCC->CFGR >> 10) & 0b111;
	if(PPRE1 < 4)
		APB1_pscal = 1;
	else
		APB1_pscal = possible_pscals[PPRE1 - 4];

	return (system_clk / AHB_pscal) / APB1_pscal;
}


/*
 * @fcn:		I2C_deinit
 *
 * @brief:		This function disables the clock of the given I2C peripheral
 *
 * @param[in]:		address of the I2C peripheral
 *
 * @return:		none
 */
void I2C_deinit(I2C_reg_t *p_I2Cx){
	if(p_I2Cx == I2C1)
	{
		I2C1_REG_RESET();
	}
	else if(p_I2Cx == I2C2)
	{
		I2C2_REG_RESET();
	}
	else if(p_I2Cx == I2C3)
	{
		I2C3_REG_RESET();
	}
}

/*
 * @fcn:			I2C_Master_send
 *
 * @brief:			This function sends the given data to the slave at the given address
 *
 * @param[in]:		address of the I2C peripheral
 * @param[in]:		address of the Tx buffer
 * @param[in]:		how many bytes of data to send
 * @param[in]:		slave address
 *
 * @return:			none
 */
void I2C_Master_send(I2C_Handle_t *p_I2C_Handle, uint8_t *p_Tx_buffer, uint32_t len, uint8_t slave_addr, uint8_t SR_enable)
{
	//generate starting condition
	I2C_generate_start(p_I2C_Handle);
	//check SB flag in SR1 to confirm that start condition is generated
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1,  I2C_SR1_SB) == 0);
	//send the address with the r/w bit set to write(0) to slave
	I2C_execute_addr_phase(p_I2C_Handle, slave_addr, WRITE);
	//check ADDR flag in SR1 to confirm address is sent
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1, I2C_SR1_ADDR) == 0);
	//clear the ADDR flag to release SCL stretch(pulled to LOW)
	I2C_clear_ADDR_flag(p_I2C_Handle);
	//send data
	while(len > 0)
	{
		while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1, I2C_SR1_TxE) == 0);
		p_I2C_Handle->p_I2Cx->DR = *p_Tx_buffer;
		p_Tx_buffer++;
		len--;
	}
	//wait until TxE=1 (data register is empty) and BTF=1 (byte transfer is finished) to close communication
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1, I2C_SR1_TxE) == 0);
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1, I2C_SR1_BTF) == 0);
	//generate stop condition if repeated start disabled
	if(SR_enable == I2C_SR_DISABLE)
		I2C_generate_stop(p_I2C_Handle);
}


void I2C_Master_receive(I2C_Handle_t *p_I2C_Handle, uint8_t *p_Rx_buffer, uint32_t len, uint8_t slave_addr, uint8_t SR_enable)
{
	//generate start condition
	I2C_generate_start(p_I2C_Handle);
	//check SB flag in SR1 to confirm that start condition is generated
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1,  I2C_SR1_SB) == 0);
	//send the address  to slave with the r/w bit set to write(0)
	I2C_execute_addr_phase(p_I2C_Handle, slave_addr, READ);
	//check ADDR flag in SR1 to confirm address is sent
	while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1, I2C_SR1_ADDR) == 0);

	//receiving only one byte of data
	/*
	 * note:
	 * 		for len == 1, must disable ACK BEFORE clearing ADDR flag and generate STOP condition AFTER RXNE flag is set.
	 * 		Clearing ADDR releases SCL, and byte transfer starts immediately. So ACK/NACK will be sent on the 9th clock (end of byte).
	 * 		If ACK bit not disabled before ADDR clear, hardware will ACK, causing slave to send another unwanted byte.
	 *
	 *		for len >= 2, can clear ADDR flag as usual and disable ACK and generate STOP when len == 2,
	 *		so the second last byte gets ACK and last byte gets NACK.
	 *
	 */
	if(len == 1)
	{
		//disable ACK
		I2C_manage_acking(p_I2C_Handle, DISABLE);
		//clear the ADDR flag to release SCL stretch(pulled to LOW), so slave start transmitting the data
		I2C_clear_ADDR_flag(p_I2C_Handle);
		//wait until RXNE is set to 1
		while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1,  I2C_SR1_RxNE) == 0);
		//generate stop condition
		if(SR_enable == I2C_SR_DISABLE)
			I2C_generate_stop(p_I2C_Handle);
		//read data from DR to Rx buffer
		*p_Rx_buffer = p_I2C_Handle->p_I2Cx->DR;
	}
	else
	{
		//clear ADDR flag so data reception begins
		I2C_clear_ADDR_flag(p_I2C_Handle);
		while(len > 0)
		{
			//wait until RXNE is set to 1, ready to read
			while(I2C_get_flag_status(p_I2C_Handle->p_I2Cx, 1,  I2C_SR1_RxNE) == 0);

			if(len == 2)		//if only 2 bytes are left to receive
			{
				//disable ACK
				I2C_manage_acking(p_I2C_Handle, DISABLE);
				//generate stop condition
				if(SR_enable == I2C_SR_DISABLE)
					I2C_generate_stop(p_I2C_Handle);
			}

			//read data from DR to Rx buffer
			*p_Rx_buffer = p_I2C_Handle->p_I2Cx->DR;
			len--;
			p_Rx_buffer++;

		}
	}
	//re-enalbe ACK if configured
	if(p_I2C_Handle->I2Cx_config.I2C_ACK_control == I2C_ACK_ENABLE)
	{
		I2C_manage_acking(p_I2C_Handle, ENABLE);
	}

}

/*
 * @fcn:				I2C_IRQ_config
 *
 * @brief:				This function enable/disable interrupt for the given peripheral
 *
 * @param[in]:			the IRQ number to enable/disable
 * @param[in]:			ENABLE or DISABLE the IRQ
 *
 * @return: 			none
 */
void I2C_IRQ_config(uint8_t IRQ_num, uint8_t enable)
{
	//enable the IRQ
	if(enable == ENABLE)
	{
		if(IRQ_num < 32)
		{
			//enable ISER0
			*NVIC_ISER0 |= (1 << IRQ_num);
		}
		else if(IRQ_num >= 32 && IRQ_num < 64)
		{
			//enable ISER1
			*NVIC_ISER1 |= (1 << (IRQ_num % 32));
		}
		else if(IRQ_num >= 64 && IRQ_num < 96){
			//enable ISER2
			*NVIC_ISER2 |= (1 << (IRQ_num % 64));
		}
		else if (IRQ_num >= 96 && IRQ_num < 128)
		{
			//enable ISER3
			*NVIC_ISER3 |= (1 << (IRQ_num % 96));
		}
	}else{ //disable the IRQ
		if(IRQ_num < 32)
		{
			//enable ICER0
			*NVIC_ICER0 |= (1 << IRQ_num);
		}
		else if(IRQ_num >= 32 && IRQ_num < 64)
		{
			//enable ICER1
			*NVIC_ICER1 |= (1 << (IRQ_num % 32));
		}
		else if(IRQ_num >= 64 && IRQ_num < 96){
			//enable ICER2
			*NVIC_ICER2 |= (1 << (IRQ_num % 64));
		}
		else if (IRQ_num >= 96 && IRQ_num < 128)
		{
			//enable ICER3
			*NVIC_ICER3 |= (1 << (IRQ_num % 96));
		}
	}

}

/*
 * @fcn:			I2C_set_priority
 *
 * @brief:			This function enable/disable the GPIO pin as given
 *
 * @param[in]:			IRQ number of the peripheral to set priority
 * @param[in]:			priority value to set the IRQ to
 *
 * @return: 		none
 */
void I2C_set_priority(uint8_t IRQ_num, uint8_t IRQ_priority)
{
	//set priority
	uint8_t iprx = IRQ_num / 4;						//which IRQ register, each IPR register only contain 4 interrupts (1 byte apart)
	uint8_t iprx_section = IRQ_num % 4;				//which interrupt(byte) within the IPR register
	uint8_t shift_amount = (8 * iprx_section) + 4; 	//add 4 because the upper 4 bits are the preemptive priority and the lower 4 are the subpriority

	*(NVIC_IPR_BASEADDR + iprx) |= (IRQ_priority << shift_amount); //NVIC_IPR_BASEADDR is uin32_t pointer so adding the iprx will be 4 bytes apart
}

/*
 * @fcn:		I2C_periph_control
 *
 * @brief:		This function enables the given I2C peripheral and the ACK bit as configured
 *
 * @param[in]:	address of the I2C peripheral
 * @param[in]:	ENABLE or DISABLE
 *
 * @return:		none
 *
 * @note:		should be called after I2C_init (after configuration is done)
 */
void I2C_periph_control(I2C_Handle_t *p_I2C_Handle, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_I2C_Handle->p_I2Cx->CR1 |= (1 << I2C_CR1_PE);
	}else
	{
		p_I2C_Handle->p_I2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
	//enable or disable ACK bit accordingly as it should only be enable after PE is set
	if(p_I2C_Handle->I2Cx_config.I2C_ACK_control == I2C_ACK_ENABLE )
	{
		I2C_manage_acking(p_I2C_Handle, ENABLE);
	}
	else
	{
		I2C_manage_acking(p_I2C_Handle, DISABLE);
	}
}

/*
 * @fcn:			get_flag_status
 *
 * @brief:			This function returns the status of the given flag bit of the I2C status register(SR)
 *
 * @param[in]:		base address of the I2C device
 * @param[in]:		which SR register to read (1 or 2)
 * @param[in]:		the flag bit of the SR register to get status from
 *
 * @return:			the status of the given flag bit
 */
uint8_t I2C_get_flag_status(I2C_reg_t *p_I2Cx, uint8_t SR, uint8_t flag_bit)
{
	if(SR == 1)
	{
		return ( (p_I2Cx->SR1 >> flag_bit) & 1 );
	}
	else
	{
		return ( (p_I2Cx->SR2 >> flag_bit) & 1 );
	}
}

/*
 * @fcn:			I2C_manage_acking
 *
 * @brief:			This function disable or enable the ACK bit of I2C_CR1 register
 *
 * @param[in]:		base address of the I2C device
 * @param[in]:		ENABLE or DISABLE
 *
 * @return:			the status of the given flag bit
 */
void I2C_manage_acking(I2C_Handle_t *p_I2C_Handle, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_I2C_Handle->p_I2Cx->CR1 |= (1 << I2C_CR1_ACK);
	}
	else if (enable == DISABLE)
	{
		p_I2C_Handle->p_I2Cx->CR1 &= ~(1 << I2C_CR1_ACK);
	}
}
/*
 * private helper functions
 */

static void I2C_generate_start(I2C_Handle_t *p_I2C_Handle)
{
	p_I2C_Handle->p_I2Cx->CR1 |= (1 << I2C_CR1_START);
}



static void I2C_execute_addr_phase(I2C_Handle_t *p_I2C_Handle, uint8_t slave_addr, uint8_t read_or_write)
{
	slave_addr = slave_addr << 1;
	if(read_or_write == WRITE)
	{
		slave_addr &= ~(1);		//r/w bit = 0
	}
	else if(read_or_write == READ)
	{
		slave_addr |= 1;		//r/w bit = 1
	}
	p_I2C_Handle->p_I2Cx->DR = slave_addr;
}

static void I2C_clear_ADDR_flag(I2C_Handle_t *p_I2C_Handle)
{
	//clear the ADDR flag by reading SR1 and SR2
	uint32_t dummy = p_I2C_Handle->p_I2Cx->SR1;
	dummy = p_I2C_Handle->p_I2Cx->SR2;
	(void)dummy;
}

static void I2C_generate_stop(I2C_Handle_t *p_I2C_Handle)
{
	p_I2C_Handle->p_I2Cx->CR1 |= (1 << I2C_CR1_STOP);
}
