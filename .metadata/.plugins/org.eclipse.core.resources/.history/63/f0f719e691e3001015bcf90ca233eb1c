/*
 * STM32F446xx.h
 *
 *  Created on: Dec 26, 2025
 *      Author: krisko
 */

#include<stdint.h>



#ifndef DRIVERS_STM32F446XX_H_
#define DRIVERS_STM32F446XX_H_

//base address of FLASH and SRAM
#define FLASH_BASEADDR 	0x08000000U
#define ROM_BASEADDR 	0x1FFF0000U
#define SRAM1_BASEADDR 	0x20000000U
#define SRAM2_BASEADDR 	0x2001C000U
#define SRAM 			SRAM1_BASEADDR


//base address of AHB and APB bus
#define APB1_BASEADDR 	0x40000000U
#define APB2_BASEADDR 	0x40010000U
#define AHB1_BASEADDR 	0x40020000U
#define AHB2_BASEADDR 	0x50000000U
#define AHB3_BASEADDR 	0x60000000U
#define PERIPH_BASEADDR APB1_BASEADDR


//base address of peripherals on AHB1
#define GPIOA_BASEADDR 	(AHB1_BASEADDR + 0x0000)
#define GPIOB_BASEADDR	(AHB1_BASEADDR + 0x0400)
#define GPIOC_BASEADDR 	(AHB1_BASEADDR + 0x0800)
#define GPIOD_BASEADDR 	(AHB1_BASEADDR + 0x0C00)
#define GPIOE_BASEADDR 	(AHB1_BASEADDR + 0x1000)
#define GPIOF_BASEADDR 	(AHB1_BASEADDR + 0x4000)
#define GPIOG_BASEADDR 	(AHB1_BASEADDR + 0x8000)
#define GPIOH_BASEADDR 	(AHB1_BASEADDR + 0xC000)

#define RCC_BASEADDR 	(AHB1_BASEADDR + 0x3800)

//base address of peripherals on APB1
#define SPI2_BASEADDR	(APB1_BASEADDR + 0x3800)
#define SPI3_BASEADDR 	(APB1_BASEADDR + 0x3C00)

#define USART2_BASEADDR (APB1_BASEADDR + 0x4400)
#define USART3_BASEADDR (APB1_BASEADDR + 0x4800)

#define UART4_BASEADDR 	(APB1_BASEADDR + 0x4C00)
#define UART5_BASEADDR 	(APB1_BASEADDR + 0x5000)

#define I2C1_BASEADDR 	(APB1_BASEADDR + 0x5400)
#define I2C2_BASEADDR 	(APB1_BASEADDR + 0x5800)
#define I2C3_BASEADDR 	(APB1_BASEADDR + 0x5C00)

//base address of peripherals on APB2
#define USART1_BASEADDR	(APB2_BASEADDR + 0x1000)
#define USART6_BASEADDR	(APB2_BASEADDR + 0x1400)

#define SPI1_BASEADDR 	(APB2_BASEADDR + 0x3000)
#define SPI4_BASEADDR 	(APB2_BASEADDR + 0x3400)

#define SYSCFG_BASEADDR (APB2_BASEADDR + 0x3800)

#define EXTI_BASEADDR	(APB2_BASEADDR + 0x3C00)


//peripheral definition structures

/*
 * use struct b/c it is very tedious to write out all the address macros for each register
 * by using uint32_t as the variables of the struct, each variable in the struct is 4 bytes or 0x0004 apart, which
 * matches the offsets of the registers so we can access the registers access via the struct, like GPIOA->MODER = ...
 */

//GPIO port registers
typedef struct{
	volatile uint32_t MODER; 	//GPIO port mode register
	volatile uint32_t OTYPER; 	//GPIO port output type register
	volatile uint32_t OSPEEDR; 	//GPIO port output speed register
	volatile uint32_t PUPDR; 	//GPIO port pull-up/pull-down register
	volatile uint32_t IDR; 		//GPIO port input data register
	volatile uint32_t ODR; 		//GPIO port output data register
	volatile uint32_t BSRR; 	//GPIO port bit set/reset register
	volatile uint32_t LCKR; 	//GPIO port configuration lock register
	volatile uint32_t AFR[2]; 	//GPIO alternate function register, AFR[0] is AFRL and AFR[1] is AFRH
}GPIO_reg_t;

//cast GPIO base addresses to GPIO_reg_t pointers
#define GPIOA 	((GPIO_reg_t*)GPIOA_BASEADDR)
#define GPIOB 	((GPIO_reg_t*)GPIOB_BASEADDR)
#define GPIOC 	((GPIO_reg_t*)GPIOC_BASEADDR)
#define GPIOD 	((GPIO_reg_t*)GPIOD_BASEADDR)
#define GPIOE 	((GPIO_reg_t*)GPIOE_BASEADDR)
#define GPIOF 	((GPIO_reg_t*)GPIOF_BASEADDR)
#define GPIOG 	((GPIO_reg_t*)GPIOG_BASEADDR)
#define GPIOH 	((GPIO_reg_t*)GPIOH_BASEADDR)

//RCC register structure
typedef struct{
	volatile uint32_t CR; 			//RCC clock control register
	volatile uint32_t PLLCFGR; 		//RCC PLL configuration register
	volatile uint32_t CFGR;			//RCC clock configuration register
	volatile uint32_t CIR;			//RCC clock interrupt register
	volatile uint32_t AHB1RSTR;		//RCC AHB1 peripheral reset register
	volatile uint32_t AHB2RSTR;		//RCC AHB2 peripheral reset register
	volatile uint32_t AHB3RSTR;		//RCC AHB3 peripheral reset register
	uint32_t RESERVED0;
	volatile uint32_t APB1RSTR; 	//RCC APB1 peripheral reset register
	volatile uint32_t APB2RSTR; 	//RCC APB2 peripheral reset register
	uint32_t RESERVED1[2];
	volatile uint32_t AHB1ENR;		//RCC AHB1 peripheral clock enable register
	volatile uint32_t AHB2ENR;		//RCC AHB2 peripheral clock enable register
	volatile uint32_t AHB3ENR;		//RCC AHB3 peripheral clock enable register
	uint32_t RESERVED2;
	volatile uint32_t APB1ENR;		//RCC APB1 peripheral clock enable register
	volatile uint32_t APB2ENR;		//RCC APB2 peripheral clock enable register
	uint32_t RESERVED3[2];
	volatile uint32_t AHB1LPENR;	//RCC AHB1 peripheral clock enable in low power mode register
	volatile uint32_t AHB2LPENR;	//RCC AHB2 peripheral clock enable in low power mode register
	volatile uint32_t AHB3LPENR;	//RCC AHB3 peripheral clock enable in low power mode register
	uint32_t RESERVED4[2];
	volatile uint32_t APB1LPENR;	//RCC APB1 peripheral clock enable in low power mode register
	volatile uint32_t APB2LPENR;	//RCC APB2 peripheral clock enabled in low power mode register
	uint32_t RESERVED5[2];
	volatile uint32_t BDCR;			//RCC Backup domain control register
	volatile uint32_t CSR;			//RCC clock control and status register
	uint32_t RESERVED6[2];
	volatile uint32_t SSCGR;		//RCC spread spectrum clock generation register
	volatile uint32_t PLLI2SCFGR;	//RCC PLLI2S configuration register
	volatile uint32_t PLLSAICFGR;	//RCC PLL configuration register
	volatile uint32_t DCKCFGR;		//RCC dedicated clock configuration register
	volatile uint32_t CKGATENR;		//RCC clocks gated enable register
	volatile uint32_t DCKCFGR2;		//RCC dedicated clocks configuration register 2
}RCC_reg_t;

#define RCC ((RCC_reg_t*) RCC_BASEADDR)

//EXTI register structure
typedef struct{
	volatile uint32_t IMR;			//Interrupt mask register
	volatile uint32_t EMR;			//Event mask register
	volatile uint32_t RTSR;			//Rising trigger selection register
	volatile uint32_t FTSR;			//Falling trigger selection register
	volatile uint32_t SWIER;		//Software interrupt event register
	volatile uint32_t PR;			//Pending register
}EXTI_reg_t;

#define EXTI ((EXTI_reg_t*) EXTI_BASEADDR)
/*
 * clock enable macros for GPIO peripherals
 */
#define GPIOA_PCLK_EN() ( RCC->AHB1ENR |= (1 << 0) )
#define GPIOB_PCLK_EN() ( RCC->AHB1ENR |= (1 << 1) )
#define GPIOC_PCLK_EN() ( RCC->AHB1ENR |= (1 << 2) )
#define GPIOD_PCLK_EN() ( RCC->AHB1ENR |= (1 << 3) )
#define GPIOE_PCLK_EN() ( RCC->AHB1ENR |= (1 << 4) )
#define GPIOF_PCLK_EN() ( RCC->AHB1ENR |= (1 << 5) )
#define GPIOG_PCLK_EN() ( RCC->AHB1ENR |= (1 << 6) )
#define GPIOH_PCLK_EN() ( RCC->AHB1ENR |= (1 << 7) )

/*
 * clock enable macros for I2C peripherals
 */
#define I2C1_PCLK_EN()	( RCC->APB1ENR |= (1 << 21) )
#define I2C2_PCLK_EN()	( RCC->APB1ENR |= (1 << 22) )
#define I2C3_PCLK_EN()	( RCC->APB1ENR |= (1 << 23) )

/*
 * clock enable macros for SPI peripherals
 */
#define SPI1_PCLK_EN()	( RCC->APB2ENR |= (1 << 12) )
#define SPI2_PCLK_EN()	( RCC->APB1ENR |= (1 << 14) )
#define SPI3_PCLK_EN()	( RCC->APB1ENR |= (1 << 15) )
#define SPI4_PCLK_EN()	( RCC->APB2ENR |= (1 << 13) )

/*
 * clock enable macros for USART peripherals
 */
#define USART1_PCLK_EN()	( RCC->APB2LPENR |= (1 << 4) )
#define USART2_PCLK_EN()	( RCC->APB1LPENR |= (1 << 17) )
#define USART3_PCLK_EN()	( RCC->APB1LPENR |= (1 << 18) )
#define UART4_PCLK_EN()		( RCC->APB1LPENR |= (1 << 19) )
#define UART5_PCLK_EN()		( RCC->APB1LPENR |= (1 << 20) )
#define USART6_PCLK_EN()	( RCC->APB2LPENR |= (1 << 5) )

/*
 * clock disable macros for GPIO peripherals
 */
#define GPIOA_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 0) )
#define GPIOB_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 1) )
#define GPIOC_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 2) )
#define GPIOD_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 3) )
#define GPIOE_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 4) )
#define GPIOF_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 5) )
#define GPIOG_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 6) )
#define GPIOH_PCLK_DI() ( RCC->AHB1ENR &= ~(1 << 7) )

/*
 * clock disable macros for I2C peripherals
 */
#define I2C1_PCLK_DI()	( RCC->APB1ENR &= ~(1 << 21) )
#define I2C2_PCLK_DI()	( RCC->APB1ENR &= ~(1 << 22) )
#define I2C3_PCLK_DI()	( RCC->APB1ENR &= ~(1 << 23) )

/*
 * clock disable macros for SPI peripherals
 */
#define SPI1_PCLK_DI()	( RCC->APB2ENR &= ~(1 << 12) )
#define SPI2_PCLK_DI()	( RCC->APB1ENR &= ~(1 << 14) )
#define SPI3_PCLK_DI()	( RCC->APB1ENR &= ~(1 << 15) )
#define SPI4_PCLK_DI()	( RCC->APB2ENR &= ~(1 << 13) )

/*
 * clock disable macros for USART peripherals
 */
#define USART1_PCLK_DI()	( RCC->APB2LPENR &= ~(1 << 4) )
#define USART2_PCLK_DI()	( RCC->APB1LPENR &= ~(1 << 17) )
#define USART3_PCLK_DI()	( RCC->APB1LPENR &= ~(1 << 18) )
#define UART4_PCLK_DI()		( RCC->APB1LPENR &= ~(1 << 19) )
#define UART5_PCLK_DI()		( RCC->APB1LPENR &= ~(1 << 20) )

/*
 * reset GPIO peripherals registers
 */
//have to set the register bit back to 0 after setting it to 1 for reset so it is releases for later use
//otherwise it will be held at reset
#define GPIOA_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 0); RCC->AHB1RSTR &= ~(1 << 0);}while(0)
#define GPIOB_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 1); RCC->AHB1RSTR &= ~(1 << 1);}while(0)
#define GPIOC_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 2); RCC->AHB1RSTR &= ~(1 << 2);}while(0)
#define GPIOD_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 3); RCC->AHB1RSTR &= ~(1 << 3);}while(0)
#define GPIOE_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 4); RCC->AHB1RSTR &= ~(1 << 4);}while(0)
#define GPIOF_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 5); RCC->AHB1RSTR &= ~(1 << 5);}while(0)
#define GPIOG_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 6); RCC->AHB1RSTR &= ~(1 << 6);}while(0)
#define GPIOH_REG_RESET()		do{ RCC->AHB1RSTR |= (1 << 7); RCC->AHB1RSTR &= ~(1 << 7);}while(0)

//some generic macros
#define ENABLE 		1
#define DISABLE 	0
#define SET 		ENABLE
#define RESET 		DISABLE
//#define GPIO_PIN_SET SET
//#define GPIO_PIN_RESET RESET

#endif /* DRIVERS_STM32F446XX_H_ */
