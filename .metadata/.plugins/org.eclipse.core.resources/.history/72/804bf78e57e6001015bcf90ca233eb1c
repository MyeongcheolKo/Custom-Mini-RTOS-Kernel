/*
 * I2C_driver.c
 *
 *  Created on: Dec 30, 2025
 *      Author: krisko
 */

#include "I2C_driver.h"

/*
 * @fcn:			I2C_clock_control
 *
 * @brief:			This function enable/disable the clock for the given I2C peripheral
 *
 * @param[in]:		address of I2C peripheral
 * @param[in]:		ENABLE or DISABLE
 *
 * @return:			none
 */
void I2C_clock_control(I2C_reg_t *p_I2Cx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		if(p_I2Cx == I2C1)
		{
			I2C1_PCLK_EN();
		}
		else if(p_I2Cx == I2C2)
		{
			I2C2_PCLK_EN();
		}
		else if(p_I2Cx == I2C3)
		{
			I2C3_PCLK_EN();
		}
	}else
	{
		if(p_I2Cx == I2C1)
		{
			I2C1_PCLK_DI();
		}
		else if(p_I2Cx == I2C2)
		{
			I2C2_PCLK_DI();
		}
		else if(p_I2Cx == I2C3)
		{
			I2C3_PCLK_DI();
		}
	}
}

void I2C_init(I2C_Handle_t *p_I2C_Handle)
{
	uint32_t temp;
	//configure ACK

}


/*
 * @fcn:		I2C_deinit
 *
 * @brief:		This function disables the clock of the given I2C peripheral
 *
 * @param[in]:		address of the I2C peripheral
 *
 * @return:		none
 */
void I2C_deinit(I2C_reg_t *p_I2Cx){
	if(p_I2Cx == I2C1)
	{
		I2C1_REG_RESET();
	}
	else if(p_I2Cx == I2C2)
	{
		I2C1_REG_RESET();
	}
	else if(p_I2Cx == I2C3)
	{
		I2C1_REG_RESET();
	}
}



/*
 * @fcn:				I2C_IRQ_config
 *
 * @brief:				This function enable/disable interrupt for the given peripheral
 *
 * @param[in]:			the IRQ number to enable/disable
 * @param[in]:			ENABLE or DISABLE the IRQ
 *
 * @return: 			none
 */
void I2C_IRQ_config(uint8_t IRQ_num, uint8_t enable)
{
	//enable the IRQ
	if(enable == ENABLE)
	{
		if(IRQ_num < 32)
		{
			//enable ISER0
			*NVIC_ISER0 |= (1 << IRQ_num);
		}
		else if(IRQ_num >= 32 && IRQ_num < 64)
		{
			//enable ISER1
			*NVIC_ISER1 |= (1 << (IRQ_num % 32));
		}
		else if(IRQ_num >= 64 && IRQ_num < 96){
			//enable ISER2
			*NVIC_ISER2 |= (1 << (IRQ_num % 64));
		}
		else if (IRQ_num >= 96 && IRQ_num < 128)
		{
			//enable ISER3
			*NVIC_ISER3 |= (1 << (IRQ_num % 96));
		}
	}else{ //disable the IRQ
		if(IRQ_num < 32)
		{
			//enable ICER0
			*NVIC_ICER0 |= (1 << IRQ_num);
		}
		else if(IRQ_num >= 32 && IRQ_num < 64)
		{
			//enable ICER1
			*NVIC_ICER1 |= (1 << (IRQ_num % 32));
		}
		else if(IRQ_num >= 64 && IRQ_num < 96){
			//enable ICER2
			*NVIC_ICER2 |= (1 << (IRQ_num % 64));
		}
		else if (IRQ_num >= 96 && IRQ_num < 128)
		{
			//enable ICER3
			*NVIC_ICER3 |= (1 << (IRQ_num % 96));
		}
	}

}

/*
 * @fcn:			I2C_set_priority
 *
 * @brief:			This function enable/disable the GPIO pin as given
 *
 * @param[in]:			IRQ number of the peripheral to set priority
 * @param[in]:			priority value to set the IRQ to
 *
 * @return: 		none
 */
void I2C_set_priority(uint8_t IRQ_num, uint8_t IRQ_priority)
{
	//set priority
	uint8_t iprx = IRQ_num / 4;						//which IRQ register, each IPR register only contain 4 interrupts (1 byte apart)
	uint8_t iprx_section = IRQ_num % 4;				//which interrupt(byte) within the IPR register
	uint8_t shift_amount = (8 * iprx_section) + 4; 	//add 4 because the upper 4 bits are the preemptive priority and the lower 4 are the subpriority

	*(NVIC_IPR_BASEADDR + iprx) |= (IRQ_priority << shift_amount); //NVIC_IPR_BASEADDR is uin32_t pointer so adding the iprx will be 4 bytes apart
}

/*
 * @fcn:		I2C_periph_control
 *
 * @brief:		This function enables the given I2C peripheral
 *
 * @param[in]:	address of the I2C peripheral
 *
 * @return:		none
 *
 * @note:		should be called after I2C_init (after configuration is done)
 */
void I2C_periph_control(I2C_reg_t *p_I2Cx, uint8_t enable)
{
	if(enable == ENABLE)
	{
		p_I2Cx->CR1 |= (1 << I2C_CR1_PE);
	}else
	{
		p_I2Cx->CR1 &= ~(1 << I2C_CR1_PE);
	}
}

/*
 * @fcn:		get_flag_status
 *
 * @brief:		This function returns the status of the given flag bit of the I2C status register(SR)
 *
 * @param[in]:		base address of the I2C device
 * @param[in]:		the flag bit of the SR register to get status from
 *
 * @return:		the status of the given flag bit
 */
uint8_t I2C_get_flag_status(I2C_reg_t *p_I2Cx, uint8_t flag_bit)
{
	if(flag_bit < 15)
	{
		return ( p_I2Cx->SR1 & (1 << flag_bit) );
	}
	return ( p_I2Cx->SR2 & (1 << flag_bit) );
}
